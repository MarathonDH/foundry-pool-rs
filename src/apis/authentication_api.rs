/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 6.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`authentication_test`]
#[derive(Clone, Debug)]
pub struct AuthenticationTestParams {
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
}

/// struct for typed errors of method [`authentication_test`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticationTestError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// Please follow these instructions for all endpoints that require authentication. You may generate an API key by creating a \"Viewer Link\" in the pool Sub-Accounts page. Use either an API key or access token (not both) to authenticate. API Keys are intended for pool customers while access tokens are intended for internal use.
pub async fn authentication_test(
    configuration: &configuration::Configuration,
    params: AuthenticationTestParams,
) -> Result<String, Error<AuthenticationTestError>> {
    let uri_str = format!("{}/authentication_test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticationTestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
