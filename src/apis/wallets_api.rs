/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 6.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`add_withdrawal_address`]
#[derive(Clone, Debug)]
pub struct AddWithdrawalAddressParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of sub-account to which the new address is being added
    pub sub_account_name: String,
    /// Label for the address to be added
    pub address_label: String,
    /// Address to be added
    pub wallet_address: String,
    /// Name of requested coin. Default value is BTC
    pub coin: Option<String>,
}

/// struct for passing parameters to the method [`get_auto_withdrawal_address`]
#[derive(Clone, Debug)]
pub struct GetAutoWithdrawalAddressParams {
    /// Name of the sub-account you want to get auto-withdrawal address for
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>,
}

/// struct for passing parameters to the method [`get_withdrawal_addresses`]
#[derive(Clone, Debug)]
pub struct GetWithdrawalAddressesParams {
    /// Name of the sub-account you want to get withdrawal addresses for
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>,
}

/// struct for passing parameters to the method [`save_auto_withdrawal_details`]
#[derive(Clone, Debug)]
pub struct SaveAutoWithdrawalDetailsParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of subAccount.
    pub sub_account_name: String,
    /// Name of requested coin.
    pub coin_string: String,
    /// A list of wallet allocation requests. Each allocation request must contain following fields
    pub wallet_allocation_request: Vec<models::WalletAllocationRequest>,
}

/// struct for passing parameters to the method [`set_auto_withdrawal_off`]
#[derive(Clone, Debug)]
pub struct SetAutoWithdrawalOffParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of the sub-account you want to deactivate auto-withdrawal for
    pub sub_account_name: String,
    /// Name of requested coin. Default value is BTC
    pub coin: Option<String>,
}

/// struct for typed errors of method [`add_withdrawal_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddWithdrawalAddressError {
    Status400(),
    Status403(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_auto_withdrawal_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAutoWithdrawalAddressError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_withdrawal_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWithdrawalAddressesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`save_auto_withdrawal_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SaveAutoWithdrawalDetailsError {
    Status400(),
    Status409(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_auto_withdrawal_off`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetAutoWithdrawalOffError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// Add a new withdrawal address for a sub-account, if your group doesn't satisfy the approval request creation threshold. Else, create an approval request to do the same. If there is an existing address where autowithdraw is ON, the new wallets allocationPercent is set to 0 and autoWithdraw is turned off. Else the new wallets allocationPercent is set to 100 and autoWithdraw is turned on. Requires authorized user.
pub async fn add_withdrawal_address(
    configuration: &configuration::Configuration,
    params: AddWithdrawalAddressParams,
) -> Result<models::WalletResponse, Error<AddWithdrawalAddressError>> {
    let uri_str = format!(
        "{}/wallets/addresses/{subAccountName}/{addressLabel}/{walletAddress}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        addressLabel = crate::apis::urlencode(params.address_label),
        walletAddress = crate::apis::urlencode(params.wallet_address)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddWithdrawalAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get addresses for a sub-account where auto-withdraw is enabled. Requires viewPayments permissions for this sub account.
pub async fn get_auto_withdrawal_address(
    configuration: &configuration::Configuration,
    params: GetAutoWithdrawalAddressParams,
) -> Result<models::WalletsResponse, Error<GetAutoWithdrawalAddressError>> {
    let uri_str = format!(
        "{}/wallets/autoWithdrawalAddress/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAutoWithdrawalAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get addresses for a sub-account. This includes addresses where auto-withdraw is either enabled or disabled. Requires viewPayments permissions for this sub account.
pub async fn get_withdrawal_addresses(
    configuration: &configuration::Configuration,
    params: GetWithdrawalAddressesParams,
) -> Result<models::WalletsResponse, Error<GetWithdrawalAddressesError>> {
    let uri_str = format!(
        "{}/wallets/addresses/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWithdrawalAddressesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Save auto-withdrawal details for a sub-account or create approval request to do the same. Requires authorized user. Addresses in the request should already be added.
pub async fn save_auto_withdrawal_details(
    configuration: &configuration::Configuration,
    params: SaveAutoWithdrawalDetailsParams,
) -> Result<i32, Error<SaveAutoWithdrawalDetailsError>> {
    let uri_str = format!(
        "{}/wallets/saveAutoWithdrawalDetails/{subAccountName}/{coinString}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        coinString = crate::apis::urlencode(params.coin_string)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());
    req_builder = req_builder.json(&params.wallet_allocation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SaveAutoWithdrawalDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Turn auto-withdrawal off for a sub-account. Requires withdraw permissions for the sub-account.
pub async fn set_auto_withdrawal_off(
    configuration: &configuration::Configuration,
    params: SetAutoWithdrawalOffParams,
) -> Result<i32, Error<SetAutoWithdrawalOffError>> {
    let uri_str = format!(
        "{}/wallets/deactivateAutoWithdrawal/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetAutoWithdrawalOffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
