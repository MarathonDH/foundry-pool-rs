/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_tag`]
#[derive(Clone, Debug)]
pub struct CreateTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name
    pub sub_account_name: String,
    /// Tag name
    pub tag_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`delete_tag`]
#[derive(Clone, Debug)]
pub struct DeleteTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name to be deleted
    pub tag_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`delete_workers_by_sub_account_name_and_worker_ids`]
#[derive(Clone, Debug)]
pub struct DeleteWorkersBySubAccountNameAndWorkerIdsParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// Name of requested coin.
    pub coin_string: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
    /// Timestamp in Unix milliseconds. Must be at least 15 minutes before current time. Workers whose last share time is equal to or older than this timestamp will be deleted.
    pub last_share_time: Option<i64>,
    /// Optional list of worker ids to be deleted.
    pub request_body: Option<Vec<i64>>
}

/// struct for passing parameters to the method [`get_tagged_worker_count`]
#[derive(Clone, Debug)]
pub struct GetTaggedWorkerCountParams {
    /// Sub-account name
    pub sub_account_name: String,
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// API key.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`get_tags`]
#[derive(Clone, Debug)]
pub struct GetTagsParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`get_worker_by_sub_account_and_worker_name`]
#[derive(Clone, Debug)]
pub struct GetWorkerBySubAccountAndWorkerNameParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// Name of requested worker.
    pub worker_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>
}

/// struct for passing parameters to the method [`get_worker_counts`]
#[derive(Clone, Debug)]
pub struct GetWorkerCountsParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Name of requested tag. Default value is \"all\".
    pub tag_name: Option<String>
}

/// struct for passing parameters to the method [`get_worker_hashrate`]
#[derive(Clone, Debug)]
pub struct GetWorkerHashrateParams {
    pub sub_account_name: String,
    pub worker_id: i64,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is one week ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current time.
    pub end: Option<String>,
    /// Start date inclusive, in unix epoch time (milliseconds). Default value is one week ago.
    pub start_date_unix_ms: Option<i64>,
    /// End date inclusive, in unix epoch time (milliseconds). Default value is current time.
    pub end_date_unix_ms: Option<i64>
}

/// struct for passing parameters to the method [`get_worker_hashrate1`]
#[derive(Clone, Debug)]
pub struct GetWorkerHashrate1Params {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// ID of requested worker.
    pub worker_id: i64,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is 30 days ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current day.
    pub end: Option<String>
}

/// struct for passing parameters to the method [`get_workers_by_sub_account`]
#[derive(Clone, Debug)]
pub struct GetWorkersBySubAccountParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Valid values are \"highestHashrate\", \"lowestHashrate\", \"highestReject\", \"lowestReject\", \"newestShareTime\", \"oldestShareTime\", \"workerName\", \"reverseWorkerName\", \"tagName\", \"reverseTagName\". Default value is highestHashrate.
    pub sort: Option<String>,
    /// Valid values are \"all\", \"online<15min\", \"offline<24hr\", or \"offline>24hr\". Default value is all.
    pub status: Option<String>,
    /// Valid values are \"all\", \"untagged\" or user created tag name. Default value is all.
    pub tag: Option<String>,
    /// Valid values are 0 and positive integers. Default value is 0.
    pub page_number: Option<i32>,
    /// Valid values are -1 (representing max size) and positive integers. Default value is -1.
    pub page_size: Option<i32>,
    /// Default value is \"\" and includes all worker names
    pub worker_name_search_str: Option<String>
}

/// struct for passing parameters to the method [`tag_workers`]
#[derive(Clone, Debug)]
pub struct TagWorkersParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name
    pub tag_name: String,
    /// List of worker ids to be tagged
    pub request_body: Vec<i32>,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`untag_workers`]
#[derive(Clone, Debug)]
pub struct UntagWorkersParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// List of worker ids to be untagged
    pub request_body: Vec<i64>,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}

/// struct for passing parameters to the method [`update_tag`]
#[derive(Clone, Debug)]
pub struct UpdateTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name to be updated
    pub tag_name: String,
    /// New tag name
    pub new_tag_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>
}


/// struct for typed errors of method [`create_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTagError {
    Status409(),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_workers_by_sub_account_name_and_worker_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkersBySubAccountNameAndWorkerIdsError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tagged_worker_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaggedWorkerCountError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_by_sub_account_and_worker_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerBySubAccountAndWorkerNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_counts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerCountsError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_hashrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerHashrateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_hashrate1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerHashrate1Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workers_by_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkersBySubAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tag_workers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TagWorkersError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`untag_workers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UntagWorkersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTagError {
    Status409(),
    Status400(),
    UnknownValue(serde_json::Value),
}


/// Create a tag. Requires permission to edit workers.
pub async fn create_tag(configuration: &configuration::Configuration, params: CreateTagParams) -> Result<i32, Error<CreateTagError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let tag_name = params.tag_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/{coinString}/{subAccountName}/{tagName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name), tagName=crate::apis::urlencode(tag_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a tag. Deleting will untag all the workers under the specified tag. Requires permission to edit workers.
pub async fn delete_tag(configuration: &configuration::Configuration, params: DeleteTagParams) -> Result<(), Error<DeleteTagError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let tag_name = params.tag_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/{coinString}/{subAccountName}/{tagName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name), tagName=crate::apis::urlencode(tag_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete workers for a sub-account by providing a list of worker ids OR by providing a last share time timestamp in milliseconds. Requires sub-account owner authentication.
pub async fn delete_workers_by_sub_account_name_and_worker_ids(configuration: &configuration::Configuration, params: DeleteWorkersBySubAccountNameAndWorkerIdsParams) -> Result<i32, Error<DeleteWorkersBySubAccountNameAndWorkerIdsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let coin_string = params.coin_string;
    let authorization = params.authorization;
    let last_share_time = params.last_share_time;
    let request_body = params.request_body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/workers/{subAccountName}/{coinString}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), coinString=crate::apis::urlencode(coin_string));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = last_share_time {
        local_var_req_builder = local_var_req_builder.query(&[("lastShareTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteWorkersBySubAccountNameAndWorkerIdsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the number of workers tagged by sub-account id and coinstring. Requires permission to view hashrate.
pub async fn get_tagged_worker_count(configuration: &configuration::Configuration, params: GetTaggedWorkerCountParams) -> Result<i32, Error<GetTaggedWorkerCountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let coin_string = params.coin_string;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/taggedWorkerCount/{coinString}/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), coinString=crate::apis::urlencode(coin_string));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTaggedWorkerCountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get worker tags. Requires permission to view hashrate.
pub async fn get_tags(configuration: &configuration::Configuration, params: GetTagsParams) -> Result<models::TagsResponse, Error<GetTagsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/{coinString}/{subAccountName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTagsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get worker stats. Requires permission to view hashrate.
pub async fn get_worker_by_sub_account_and_worker_name(configuration: &configuration::Configuration, params: GetWorkerBySubAccountAndWorkerNameParams) -> Result<models::WorkerResponse, Error<GetWorkerBySubAccountAndWorkerNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let worker_name = params.worker_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/workers/{subAccountName}/{workerName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), workerName=crate::apis::urlencode(worker_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetWorkerBySubAccountAndWorkerNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get worker counts by tag name. Requires permission to view hashrate.
pub async fn get_worker_counts(configuration: &configuration::Configuration, params: GetWorkerCountsParams) -> Result<models::WorkerCounts, Error<GetWorkerCountsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let tag_name = params.tag_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/workers/workerCounts/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tag_name {
        local_var_req_builder = local_var_req_builder.query(&[("tagName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetWorkerCountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get worker hashrate per hour for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_worker_hashrate(configuration: &configuration::Configuration, params: GetWorkerHashrateParams) -> Result<Vec<models::HashrateResponse>, Error<GetWorkerHashrateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let worker_id = params.worker_id;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let start = params.start;
    let end = params.end;
    let start_date_unix_ms = params.start_date_unix_ms;
    let end_date_unix_ms = params.end_date_unix_ms;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/worker_hashrate_hour/{subAccountName}/{workerId}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), workerId=worker_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date_unix_ms {
        local_var_req_builder = local_var_req_builder.query(&[("startDateUnixMs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date_unix_ms {
        local_var_req_builder = local_var_req_builder.query(&[("endDateUnixMs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetWorkerHashrateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get worker hashrate per day for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_worker_hashrate1(configuration: &configuration::Configuration, params: GetWorkerHashrate1Params) -> Result<Vec<models::HashrateResponse>, Error<GetWorkerHashrate1Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let worker_id = params.worker_id;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let start = params.start;
    let end = params.end;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/worker_hashrate_day/{subAccountName}/{workerId}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), workerId=worker_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetWorkerHashrate1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all worker stats for a sub-account. Requires permission to view hashrate.
pub async fn get_workers_by_sub_account(configuration: &configuration::Configuration, params: GetWorkersBySubAccountParams) -> Result<models::WorkersResponse, Error<GetWorkersBySubAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let sort = params.sort;
    let status = params.status;
    let tag = params.tag;
    let page_number = params.page_number;
    let page_size = params.page_size;
    let worker_name_search_str = params.worker_name_search_str;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/workers/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tag {
        local_var_req_builder = local_var_req_builder.query(&[("tag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_number {
        local_var_req_builder = local_var_req_builder.query(&[("pageNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = worker_name_search_str {
        local_var_req_builder = local_var_req_builder.query(&[("workerNameSearchStr", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetWorkersBySubAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Tag a list of workers. Requires permission to edit workers.
pub async fn tag_workers(configuration: &configuration::Configuration, params: TagWorkersParams) -> Result<i32, Error<TagWorkersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let tag_name = params.tag_name;
    let request_body = params.request_body;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/tag/{coinString}/{subAccountName}/{tagName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name), tagName=crate::apis::urlencode(tag_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TagWorkersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Untag a list of workers. Requires permission to edit workers.
pub async fn untag_workers(configuration: &configuration::Configuration, params: UntagWorkersParams) -> Result<(), Error<UntagWorkersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let request_body = params.request_body;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/untag/{coinString}/{subAccountName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UntagWorkersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a tag name. Requires permission to edit workers.
pub async fn update_tag(configuration: &configuration::Configuration, params: UpdateTagParams) -> Result<i32, Error<UpdateTagError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let coin_string = params.coin_string;
    let sub_account_name = params.sub_account_name;
    let tag_name = params.tag_name;
    let new_tag_name = params.new_tag_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tags/update/{coinString}/{subAccountName}/{tagName}/{newTagName}", local_var_configuration.base_path, coinString=crate::apis::urlencode(coin_string), subAccountName=crate::apis::urlencode(sub_account_name), tagName=crate::apis::urlencode(tag_name), newTagName=crate::apis::urlencode(new_tag_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateTagError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

