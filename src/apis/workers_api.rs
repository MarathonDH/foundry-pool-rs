/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 6.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`create_tag`]
#[derive(Clone, Debug)]
pub struct CreateTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name
    pub sub_account_name: String,
    /// Tag name
    pub tag_name: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
}

/// struct for passing parameters to the method [`delete_tag`]
#[derive(Clone, Debug)]
pub struct DeleteTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name to be deleted
    pub tag_name: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
}

/// struct for passing parameters to the method [`delete_workers_by_sub_account_name_and_worker_ids`]
#[derive(Clone, Debug)]
pub struct DeleteWorkersBySubAccountNameAndWorkerIdsParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// Name of requested coin.
    pub coin_string: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
    /// Timestamp in Unix milliseconds. Must be at least 15 minutes before current time. Workers whose last share time is equal to or older than this timestamp will be deleted.
    pub last_share_time: Option<i64>,
    /// Optional list of worker ids to be deleted.
    pub request_body: Option<Vec<i64>>,
}

/// struct for passing parameters to the method [`get_tagged_worker_count`]
#[derive(Clone, Debug)]
pub struct GetTaggedWorkerCountParams {
    /// Sub-account name
    pub sub_account_name: String,
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// API key.
    pub x_api_key: Option<String>,
}

/// struct for passing parameters to the method [`get_tags`]
#[derive(Clone, Debug)]
pub struct GetTagsParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
}

/// struct for passing parameters to the method [`get_worker_by_sub_account_and_worker_name`]
#[derive(Clone, Debug)]
pub struct GetWorkerBySubAccountAndWorkerNameParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// Name of requested worker.
    pub worker_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>,
}

/// struct for passing parameters to the method [`get_worker_counts`]
#[derive(Clone, Debug)]
pub struct GetWorkerCountsParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Name of requested tag. Default value is \"all\".
    pub tag_name: Option<String>,
}

/// struct for passing parameters to the method [`get_worker_hashrate`]
#[derive(Clone, Debug)]
pub struct GetWorkerHashrateParams {
    pub sub_account_name: String,
    pub worker_id: i64,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is one week ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current time.
    pub end: Option<String>,
    /// Start date inclusive, in unix epoch time (milliseconds). Default value is one week ago.
    pub start_date_unix_ms: Option<i64>,
    /// End date inclusive, in unix epoch time (milliseconds). Default value is current time.
    pub end_date_unix_ms: Option<i64>,
}

/// struct for passing parameters to the method [`get_worker_hashrate1`]
#[derive(Clone, Debug)]
pub struct GetWorkerHashrate1Params {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// ID of requested worker.
    pub worker_id: i64,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is 30 days ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current day.
    pub end: Option<String>,
}

/// struct for passing parameters to the method [`get_workers_by_sub_account`]
#[derive(Clone, Debug)]
pub struct GetWorkersBySubAccountParams {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Valid values are \"highestHashrate\", \"lowestHashrate\", \"highestReject\", \"lowestReject\", \"newestShareTime\", \"oldestShareTime\", \"workerName\", \"reverseWorkerName\", \"tagName\", \"reverseTagName\". Default value is highestHashrate.
    pub sort: Option<String>,
    /// Valid values are \"all\", \"online<15min\", \"offline<24hr\", or \"offline>24hr\". Default value is all.
    pub status: Option<String>,
    /// Valid values are \"all\", \"untagged\" or user created tag name. Default value is all.
    pub tag: Option<String>,
    /// Valid values are 0 and positive integers. Default value is 0.
    pub page_number: Option<i32>,
    /// Valid values are -1 (representing max size) and positive integers. Default value is -1.
    pub page_size: Option<i32>,
    /// Default value is \"\" and includes all worker names
    pub worker_name_search_str: Option<String>,
}

/// struct for passing parameters to the method [`tag_workers`]
#[derive(Clone, Debug)]
pub struct TagWorkersParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name
    pub tag_name: String,
    /// List of worker ids to be tagged
    pub request_body: Vec<i64>,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
}

/// struct for passing parameters to the method [`untag_workers`]
#[derive(Clone, Debug)]
pub struct UntagWorkersParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// List of worker ids to be untagged
    pub request_body: Vec<i64>,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
}

/// struct for passing parameters to the method [`update_tag`]
#[derive(Clone, Debug)]
pub struct UpdateTagParams {
    /// Coin string. valid values are \"BTC\" or \"BCH\"
    pub coin_string: String,
    /// Sub-account name associated with the tag
    pub sub_account_name: String,
    /// Tag name to be updated
    pub tag_name: String,
    /// New tag name
    pub new_tag_name: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
}

/// struct for typed errors of method [`create_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTagError {
    Status409(),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTagError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_workers_by_sub_account_name_and_worker_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkersBySubAccountNameAndWorkerIdsError {
    Status400(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tagged_worker_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaggedWorkerCountError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_by_sub_account_and_worker_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerBySubAccountAndWorkerNameError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_counts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerCountsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_hashrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerHashrateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_worker_hashrate1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkerHashrate1Error {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workers_by_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkersBySubAccountError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tag_workers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TagWorkersError {
    Status400(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`untag_workers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UntagWorkersError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTagError {
    Status400(),
    Status403(),
    Status404(i32),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// Create a tag. Requires permission to edit workers.
pub async fn create_tag(
    configuration: &configuration::Configuration,
    params: CreateTagParams,
) -> Result<i32, Error<CreateTagError>> {
    let uri_str = format!(
        "{}/tags/{coinString}/{subAccountName}/{tagName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        tagName = crate::apis::urlencode(params.tag_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a tag. Deleting will untag all the workers under the specified tag. Requires permission to edit workers.
pub async fn delete_tag(
    configuration: &configuration::Configuration,
    params: DeleteTagParams,
) -> Result<(), Error<DeleteTagError>> {
    let uri_str = format!(
        "{}/tags/{coinString}/{subAccountName}/{tagName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        tagName = crate::apis::urlencode(params.tag_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete workers for a sub-account by providing a list of worker ids OR by providing a last share time timestamp in milliseconds. Requires sub-account owner authentication.
pub async fn delete_workers_by_sub_account_name_and_worker_ids(
    configuration: &configuration::Configuration,
    params: DeleteWorkersBySubAccountNameAndWorkerIdsParams,
) -> Result<i32, Error<DeleteWorkersBySubAccountNameAndWorkerIdsError>> {
    let uri_str = format!(
        "{}/workers/{subAccountName}/{coinString}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        coinString = crate::apis::urlencode(params.coin_string)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.last_share_time {
        req_builder = req_builder.query(&[("lastShareTime", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    req_builder = req_builder.json(&params.request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWorkersBySubAccountNameAndWorkerIdsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the number of workers tagged by sub-account id and coinstring. Requires permission to view hashrate.
pub async fn get_tagged_worker_count(
    configuration: &configuration::Configuration,
    params: GetTaggedWorkerCountParams,
) -> Result<i32, Error<GetTaggedWorkerCountError>> {
    let uri_str = format!(
        "{}/tags/taggedWorkerCount/{coinString}/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        coinString = crate::apis::urlencode(params.coin_string)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTaggedWorkerCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get worker tags. Requires permission to view hashrate.
pub async fn get_tags(
    configuration: &configuration::Configuration,
    params: GetTagsParams,
) -> Result<models::TagsResponse, Error<GetTagsError>> {
    let uri_str = format!(
        "{}/tags/{coinString}/{subAccountName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TagsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TagsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get worker stats. Requires permission to view hashrate.
pub async fn get_worker_by_sub_account_and_worker_name(
    configuration: &configuration::Configuration,
    params: GetWorkerBySubAccountAndWorkerNameParams,
) -> Result<models::WorkerResponse, Error<GetWorkerBySubAccountAndWorkerNameError>> {
    let uri_str = format!(
        "{}/workers/{subAccountName}/{workerName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        workerName = crate::apis::urlencode(params.worker_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkerResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkerBySubAccountAndWorkerNameError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get worker counts by tag name. Requires permission to view hashrate.
pub async fn get_worker_counts(
    configuration: &configuration::Configuration,
    params: GetWorkerCountsParams,
) -> Result<models::WorkerCounts, Error<GetWorkerCountsError>> {
    let uri_str = format!(
        "{}/workers/workerCounts/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag_name {
        req_builder = req_builder.query(&[("tagName", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkerCounts`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkerCounts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkerCountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get worker hashrate per hour (in GH/s) for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_worker_hashrate(
    configuration: &configuration::Configuration,
    params: GetWorkerHashrateParams,
) -> Result<Vec<models::HashrateResponse>, Error<GetWorkerHashrateError>> {
    let uri_str = format!(
        "{}/worker_hashrate_hour/{subAccountName}/{workerId}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        workerId = params.worker_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start_date_unix_ms {
        req_builder = req_builder.query(&[("startDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end_date_unix_ms {
        req_builder = req_builder.query(&[("endDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkerHashrateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get worker hashrate per day (in GH/s) for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_worker_hashrate1(
    configuration: &configuration::Configuration,
    params: GetWorkerHashrate1Params,
) -> Result<Vec<models::HashrateResponse>, Error<GetWorkerHashrate1Error>> {
    let uri_str = format!(
        "{}/worker_hashrate_day/{subAccountName}/{workerId}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        workerId = params.worker_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkerHashrate1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all worker stats for a sub-account. Requires permission to view hashrate.
pub async fn get_workers_by_sub_account(
    configuration: &configuration::Configuration,
    params: GetWorkersBySubAccountParams,
) -> Result<models::WorkersResponse, Error<GetWorkersBySubAccountError>> {
    let uri_str = format!(
        "{}/workers/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_number {
        req_builder = req_builder.query(&[("pageNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.worker_name_search_str {
        req_builder = req_builder.query(&[("workerNameSearchStr", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkersResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkersBySubAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Tag a list of workers. Requires permission to edit workers.
pub async fn tag_workers(
    configuration: &configuration::Configuration,
    params: TagWorkersParams,
) -> Result<i32, Error<TagWorkersError>> {
    let uri_str = format!(
        "{}/tags/tag/{coinString}/{subAccountName}/{tagName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        tagName = crate::apis::urlencode(params.tag_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    req_builder = req_builder.json(&params.request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TagWorkersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Untag a list of workers. Requires permission to edit workers.
pub async fn untag_workers(
    configuration: &configuration::Configuration,
    params: UntagWorkersParams,
) -> Result<(), Error<UntagWorkersError>> {
    let uri_str = format!(
        "{}/tags/untag/{coinString}/{subAccountName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    req_builder = req_builder.json(&params.request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UntagWorkersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a tag name. Requires permission to edit workers. Cannot update tag name to 'all' or 'untagged'.
pub async fn update_tag(
    configuration: &configuration::Configuration,
    params: UpdateTagParams,
) -> Result<i32, Error<UpdateTagError>> {
    let uri_str = format!(
        "{}/tags/update/{coinString}/{subAccountName}/{tagName}/{newTagName}",
        configuration.base_path,
        coinString = crate::apis::urlencode(params.coin_string),
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        tagName = crate::apis::urlencode(params.tag_name),
        newTagName = crate::apis::urlencode(params.new_tag_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
