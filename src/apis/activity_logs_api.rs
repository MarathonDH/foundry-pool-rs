/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 6.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`get_activity_log_for_groups`]
#[derive(Clone, Debug)]
pub struct GetActivityLogForGroupsParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// List of Group IDs is optional. If no list is passed, all groups the logged-in user has view permissions for is returned.
    pub group_ids_list: Option<Vec<i32>>,
    /// Start date inclusive, in unix epoch time (milliseconds). Default value is 30 days ago.
    pub start_date_unix_ms: Option<i64>,
    /// End date inclusive, in unix epoch time (milliseconds). Default value is current time.
    pub end_date_unix_ms: Option<i64>,
    /// Valid values are 0 and positive integers.
    pub page_number: Option<i32>,
    /// Valid values are -1 (representing max size) and positive integers.
    pub page_size: Option<i32>,
    /// Filter logs by coin.
    pub coin: Option<String>,
    /// Filter logs by activity type. List of available activity types can be GET from /activity_log/activity_types endpoint
    pub activity_type: Option<String>,
    /// Filter logs by a user's email address
    pub user_email: Option<String>,
    /// Filter logs by a subAccountName for a Group in which that SubAccount exists
    pub sub_account_name: Option<String>,
    /// Sort the logs by \"newest\" or \"oldest\" case-sensitive.
    pub sort: Option<String>,
    /// Filter logs by hiding all auth0 activity types.
    pub hide_auth_logs: Option<bool>,
}

/// struct for passing parameters to the method [`get_activity_log_types`]
#[derive(Clone, Debug)]
pub struct GetActivityLogTypesParams {
    /// OAuth2.0 access token.
    pub authorization: String,
}

/// struct for typed errors of method [`get_activity_log_for_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActivityLogForGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_activity_log_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActivityLogTypesError {
    UnknownValue(serde_json::Value),
}

/// Get activity logs for a list of groups. Mining account owner or accountant authentication required to see own groups activity log. Admin authentication with read permission required to see other groups activity log.
pub async fn get_activity_log_for_groups(
    configuration: &configuration::Configuration,
    params: GetActivityLogForGroupsParams,
) -> Result<models::ActivityLogResponseV2WithTotal, Error<GetActivityLogForGroupsError>> {
    let uri_str = format!("{}/v2/activity_log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.group_ids_list {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("groupIdsList".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "groupIdsList",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.start_date_unix_ms {
        req_builder = req_builder.query(&[("startDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end_date_unix_ms {
        req_builder = req_builder.query(&[("endDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_number {
        req_builder = req_builder.query(&[("pageNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.activity_type {
        req_builder = req_builder.query(&[("activityType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.user_email {
        req_builder = req_builder.query(&[("userEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sub_account_name {
        req_builder = req_builder.query(&[("subAccountName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hide_auth_logs {
        req_builder = req_builder.query(&[("hideAuthLogs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityLogResponseV2WithTotal`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityLogResponseV2WithTotal`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetActivityLogForGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get list of activities types that are currently being logged by the pool.
pub async fn get_activity_log_types(
    configuration: &configuration::Configuration,
    params: GetActivityLogTypesParams,
) -> Result<Vec<models::ActivityTypesEnumResponse>, Error<GetActivityLogTypesError>> {
    let uri_str = format!("{}/activity_log/activity_types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ActivityTypesEnumResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ActivityTypesEnumResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetActivityLogTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
