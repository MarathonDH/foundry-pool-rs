/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 6.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`archive_sub_account`]
#[derive(Clone, Debug)]
pub struct ArchiveSubAccountParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of the sub-account to be archived
    pub sub_account_name: String,
}

/// struct for passing parameters to the method [`create_sub_account_and_add_withdrawal_address_for_group`]
#[derive(Clone, Debug)]
pub struct CreateSubAccountAndAddWithdrawalAddressForGroupParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of the new sub-account
    pub sub_account_name: String,
    /// Group ID for the group to which the sub-account belongs
    pub group_id: i32,
    /// Label for the new withdrawal address
    pub address_label: String,
    /// Withdrawal address
    pub wallet_address: String,
    /// Name of requested coin.
    pub coin: Option<String>,
    /// User ID for the owner of the new-subaccount. Default value is the user ID associated with your access token. Do not include this param if you're not an admin. Only admins with write permission can create sub-accounts on behalf of other users.
    pub user_id: Option<String>,
    /// An optional array specifying users and their sub-account role. All group owners must be present in the array. Each array entry must contain the following fields. userId: an Integer that corresponds to a User ID. subAccountRole: a String that represents the subAccountRole you want to be given to the User ID, Allowed values for subAccountRole are \"owner\", \"technician\" or \"accountant\"
    pub sub_account_access_request: Option<Vec<models::SubAccountAccessRequest>>,
}

/// struct for passing parameters to the method [`get_granted_sub_account_stats`]
#[derive(Clone, Debug)]
pub struct GetGrantedSubAccountStatsParams {
    /// User ID is optional. Defaults to logged in user.
    pub user_id: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Valid values are \"highestHashrate\" or \"subAccountName\".
    pub sort: Option<String>,
    /// List of group ids.
    pub group_ids_list: Option<Vec<i32>>,
    /// Optional boolean which determines if archived sub-accounts should be included. Defaults to false.
    pub archived: Option<bool>,
}

/// struct for passing parameters to the method [`get_sub_account_hashrate`]
#[derive(Clone, Debug)]
pub struct GetSubAccountHashrateParams {
    pub sub_account_name: String,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in yyyy-MM-ddThh:mm:ss.SSS string format. Default value is one week ago.
    pub start: Option<String>,
    /// End date inclusive, in yyyy-MM-ddThh:mm:ss.SSS string format. Default value is current time.
    pub end: Option<String>,
    /// Start date inclusive, in unix epoch time (milliseconds). Default value is one week ago.
    pub start_date_unix_ms: Option<i64>,
    /// End date inclusive, in unix epoch time (milliseconds). Default value is current time.
    pub end_date_unix_ms: Option<i64>,
}

/// struct for passing parameters to the method [`get_sub_account_hashrate1`]
#[derive(Clone, Debug)]
pub struct GetSubAccountHashrate1Params {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is 30 days ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current day.
    pub end: Option<String>,
}

/// struct for passing parameters to the method [`get_sub_account_stats`]
#[derive(Clone, Debug)]
pub struct GetSubAccountStatsParams {
    /// Sub-Account Name
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Name of requested tag. Default value is all.
    pub tag_name: Option<String>,
}

/// struct for passing parameters to the method [`unarchive_sub_account`]
#[derive(Clone, Debug)]
pub struct UnarchiveSubAccountParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of the sub-account to be unarchived
    pub sub_account_name: String,
}

/// struct for typed errors of method [`archive_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArchiveSubAccountError {
    Status409(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sub_account_and_add_withdrawal_address_for_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubAccountAndAddWithdrawalAddressForGroupError {
    Status400(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_granted_sub_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGrantedSubAccountStatsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_hashrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountHashrateError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_hashrate1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountHashrate1Error {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountStatsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unarchive_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnarchiveSubAccountError {
    Status409(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Archive sub-account with no balance and zero hashrate for past 24 hours. Requires sub-account owner permissions
pub async fn archive_sub_account(
    configuration: &configuration::Configuration,
    params: ArchiveSubAccountParams,
) -> Result<(), Error<ArchiveSubAccountError>> {
    let uri_str = format!(
        "{}/sub_account/archive/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ArchiveSubAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new sub-account for given group and add an initial withdrawal address to it, if your group doesn't satisfy the approval request creation threshold. Else, create an approval request to do the same. Requires sub-account owner authentication.
pub async fn create_sub_account_and_add_withdrawal_address_for_group(
    configuration: &configuration::Configuration,
    params: CreateSubAccountAndAddWithdrawalAddressForGroupParams,
) -> Result<models::WalletResponse, Error<CreateSubAccountAndAddWithdrawalAddressForGroupError>> {
    let uri_str = format!(
        "{}/v2/sub_account/{subAccountName}/group/{groupId}/{addressLabel}/{walletAddress}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name),
        groupId = params.group_id,
        addressLabel = crate::apis::urlencode(params.address_label),
        walletAddress = crate::apis::urlencode(params.wallet_address)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());
    req_builder = req_builder.json(&params.sub_account_access_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSubAccountAndAddWithdrawalAddressForGroupError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get stats for sub-accounts that the user owns or has granted access to. User authentication required to see their own granted sub-accounts. Admin authentication with read permission required to see other users granted sub-accounts.
pub async fn get_granted_sub_account_stats(
    configuration: &configuration::Configuration,
    params: GetGrantedSubAccountStatsParams,
) -> Result<Vec<models::SubAccountStatsWithRoleResponse>, Error<GetGrantedSubAccountStatsError>> {
    let uri_str = format!(
        "{}/granted_subaccount_stats/{userId}",
        configuration.base_path,
        userId = crate::apis::urlencode(params.user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_ids_list {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("groupIdsList".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "groupIdsList",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.archived {
        req_builder = req_builder.query(&[("archived", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SubAccountStatsWithRoleResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SubAccountStatsWithRoleResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGrantedSubAccountStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get sub-account hashrate per hour for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_sub_account_hashrate(
    configuration: &configuration::Configuration,
    params: GetSubAccountHashrateParams,
) -> Result<Vec<models::HashrateResponse>, Error<GetSubAccountHashrateError>> {
    let uri_str = format!(
        "{}/subaccount_hashrate_hour/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start_date_unix_ms {
        req_builder = req_builder.query(&[("startDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end_date_unix_ms {
        req_builder = req_builder.query(&[("endDateUnixMs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubAccountHashrateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get sub-account hashrate and average active workers per day for a requested date range & coin. Requires permission to view hashrate. Note: Average Workers would be -1.0 for the current UTC day and also if the calculation is pending.
pub async fn get_sub_account_hashrate1(
    configuration: &configuration::Configuration,
    params: GetSubAccountHashrate1Params,
) -> Result<Vec<models::HashrateResponse>, Error<GetSubAccountHashrate1Error>> {
    let uri_str = format!(
        "{}/subaccount_hashrate_day/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HashrateResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubAccountHashrate1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get sub-account stats. Requires permission to view hashrate.
pub async fn get_sub_account_stats(
    configuration: &configuration::Configuration,
    params: GetSubAccountStatsParams,
) -> Result<models::SubAccountStatsWithoutOwnersResponse, Error<GetSubAccountStatsError>> {
    let uri_str = format!(
        "{}/subaccount_stats/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.coin {
        req_builder = req_builder.query(&[("coin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag_name {
        req_builder = req_builder.query(&[("tagName", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = params.x_api_key {
        req_builder = req_builder.header("X-API-KEY", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubAccountStatsWithoutOwnersResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubAccountStatsWithoutOwnersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubAccountStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unarchive inactive sub-account. Requires sub-account owner permissions
pub async fn unarchive_sub_account(
    configuration: &configuration::Configuration,
    params: UnarchiveSubAccountParams,
) -> Result<(), Error<UnarchiveSubAccountError>> {
    let uri_str = format!(
        "{}/sub_account/unarchive/{subAccountName}",
        configuration.base_path,
        subAccountName = crate::apis::urlencode(params.sub_account_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", params.authorization.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnarchiveSubAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
