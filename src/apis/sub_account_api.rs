/*
 * Foundry USA Pool API
 *
 * The Foundry USA Pool API allows users to view data and perform actions using custom written software. To get started, please follow the instructions in the Authentication Test endpoint.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_sub_account_and_add_withdrawal_address_for_group`]
#[derive(Clone, Debug)]
pub struct CreateSubAccountAndAddWithdrawalAddressForGroupParams {
    /// OAuth2.0 access token.
    pub authorization: String,
    /// Name of the new sub-account
    pub sub_account_name: String,
    /// Group ID for the group to which the sub-account belongs
    pub group_id: i32,
    /// Label for the new withdrawal address
    pub address_label: String,
    /// Withdrawal address
    pub wallet_address: String,
    /// Name of requested coin.
    pub coin: Option<String>,
    /// User ID for the owner of the new-subaccount. Default value is the user ID associated with your access token. Do not include this param if you're not an admin. Only admins with write permission can create sub-accounts on behalf of other users.
    pub user_id: Option<String>,
    /// An optional array specifying users and their sub-account role. All group owners must be present in the array. Each array entry must contain the following fields. userId: an Integer that corresponds to a User ID. subAccountRole: a String that represents the subAccountRole you want to be given to the User ID, Allowed values for subAccountRole are \"owner\", \"technician\" or \"accountant\"
    pub sub_account_access_request: Option<Vec<models::SubAccountAccessRequest>>
}

/// struct for passing parameters to the method [`delete_sub_account`]
#[derive(Clone, Debug)]
pub struct DeleteSubAccountParams {
    /// Name of the sub-account to be deleted
    pub sub_account_name: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>
}

/// struct for passing parameters to the method [`get_granted_sub_account_stats`]
#[derive(Clone, Debug)]
pub struct GetGrantedSubAccountStatsParams {
    /// User ID is optional. Defaults to logged in user.
    pub user_id: String,
    /// OAuth2.0 access token.
    pub authorization: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Valid values are \"highestHashrate\" or \"subAccountName\".
    pub sort: Option<String>,
    /// List of group ids.
    pub group_ids_list: Option<Vec<i32>>
}

/// struct for passing parameters to the method [`get_sub_account_hashrate`]
#[derive(Clone, Debug)]
pub struct GetSubAccountHashrateParams {
    pub sub_account_name: String,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in yyyy-MM-ddThh:mm:ss.SSS string format. Default value is one week ago.
    pub start: Option<String>,
    /// End date inclusive, in yyyy-MM-ddThh:mm:ss.SSS string format. Default value is current time.
    pub end: Option<String>,
    /// Start date inclusive, in unix epoch time (milliseconds). Default value is one week ago.
    pub start_date_unix_ms: Option<i64>,
    /// End date inclusive, in unix epoch time (milliseconds). Default value is current time.
    pub end_date_unix_ms: Option<i64>
}

/// struct for passing parameters to the method [`get_sub_account_hashrate1`]
#[derive(Clone, Debug)]
pub struct GetSubAccountHashrate1Params {
    /// Name of requested sub-account.
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Start date inclusive, in YYYY-MM-DD string format. Default value is 30 days ago.
    pub start: Option<String>,
    /// End date inclusive, in YYYY-MM-DD string format. Default value is current day.
    pub end: Option<String>
}

/// struct for passing parameters to the method [`get_sub_account_stats`]
#[derive(Clone, Debug)]
pub struct GetSubAccountStatsParams {
    /// Sub-Account Name
    pub sub_account_name: String,
    /// OAuth2.0 access token. Not required if using API key.
    pub authorization: Option<String>,
    /// API key. Not required if using access token.
    pub x_api_key: Option<String>,
    /// Name of requested coin. Default value is BTC.
    pub coin: Option<String>,
    /// Name of requested tag. Default value is all.
    pub tag_name: Option<String>
}


/// struct for typed errors of method [`create_sub_account_and_add_withdrawal_address_for_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubAccountAndAddWithdrawalAddressForGroupError {
    Status400(),
    Status403(),
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sub_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_granted_sub_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGrantedSubAccountStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_hashrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountHashrateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_hashrate1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountHashrate1Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_account_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubAccountStatsError {
    UnknownValue(serde_json::Value),
}


/// Create a new sub-account for given group and add an initial withdrawal address to it, if your group doesn't satisfy the approval request creation threshold. Else, create an approval request to do the same. Requires sub-account owner authentication.
pub async fn create_sub_account_and_add_withdrawal_address_for_group(configuration: &configuration::Configuration, params: CreateSubAccountAndAddWithdrawalAddressForGroupParams) -> Result<models::WalletResponse, Error<CreateSubAccountAndAddWithdrawalAddressForGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let authorization = params.authorization;
    let sub_account_name = params.sub_account_name;
    let group_id = params.group_id;
    let address_label = params.address_label;
    let wallet_address = params.wallet_address;
    let coin = params.coin;
    let user_id = params.user_id;
    let sub_account_access_request = params.sub_account_access_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/sub_account/{subAccountName}/group/{groupId}/{addressLabel}/{walletAddress}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name), groupId=group_id, addressLabel=crate::apis::urlencode(address_label), walletAddress=crate::apis::urlencode(wallet_address));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("user_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.json(&sub_account_access_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSubAccountAndAddWithdrawalAddressForGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete sub-account with no mining history. Requires permission to create sub-account.
pub async fn delete_sub_account(configuration: &configuration::Configuration, params: DeleteSubAccountParams) -> Result<(), Error<DeleteSubAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/sub_account/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteSubAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get stats for sub-accounts that the user owns or has granted access to. User authentication required to see their own granted sub-accounts. Admin authentication with read permission required to see other users granted sub-accounts.
pub async fn get_granted_sub_account_stats(configuration: &configuration::Configuration, params: GetGrantedSubAccountStatsParams) -> Result<Vec<models::SubAccountStatsWithRoleResponse>, Error<GetGrantedSubAccountStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let authorization = params.authorization;
    let coin = params.coin;
    let sort = params.sort;
    let group_ids_list = params.group_ids_list;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/granted_subaccount_stats/{userId}", local_var_configuration.base_path, userId=crate::apis::urlencode(user_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_ids_list {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("groupIdsList".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("groupIdsList", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetGrantedSubAccountStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get sub-account hashrate per hour for a requested date range & coin. Requires permission to view hashrate.
pub async fn get_sub_account_hashrate(configuration: &configuration::Configuration, params: GetSubAccountHashrateParams) -> Result<Vec<models::HashrateResponse>, Error<GetSubAccountHashrateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let x_api_key = params.x_api_key;
    let authorization = params.authorization;
    let coin = params.coin;
    let start = params.start;
    let end = params.end;
    let start_date_unix_ms = params.start_date_unix_ms;
    let end_date_unix_ms = params.end_date_unix_ms;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subaccount_hashrate_hour/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date_unix_ms {
        local_var_req_builder = local_var_req_builder.query(&[("startDateUnixMs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date_unix_ms {
        local_var_req_builder = local_var_req_builder.query(&[("endDateUnixMs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubAccountHashrateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get sub-account hashrate and average active workers per day for a requested date range & coin. Requires permission to view hashrate. Note: Average Workers would be -1.0 for the current UTC day and also if the calculation is pending.
pub async fn get_sub_account_hashrate1(configuration: &configuration::Configuration, params: GetSubAccountHashrate1Params) -> Result<Vec<models::HashrateResponse>, Error<GetSubAccountHashrate1Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let start = params.start;
    let end = params.end;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subaccount_hashrate_day/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubAccountHashrate1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get sub-account stats. Requires permission to view hashrate.
pub async fn get_sub_account_stats(configuration: &configuration::Configuration, params: GetSubAccountStatsParams) -> Result<models::SubAccountStatsWithoutOwnersResponse, Error<GetSubAccountStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sub_account_name = params.sub_account_name;
    let authorization = params.authorization;
    let x_api_key = params.x_api_key;
    let coin = params.coin;
    let tag_name = params.tag_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subaccount_stats/{subAccountName}", local_var_configuration.base_path, subAccountName=crate::apis::urlencode(sub_account_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = coin {
        local_var_req_builder = local_var_req_builder.query(&[("coin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tag_name {
        local_var_req_builder = local_var_req_builder.query(&[("tagName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_api_key {
        local_var_req_builder = local_var_req_builder.header("X-API-KEY", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubAccountStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

